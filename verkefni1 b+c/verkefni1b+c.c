#pragma config(Sensor, in1,    Gyro,           sensorGyro)
#pragma config(Sensor, in2,    Light,          sensorReflection)
#pragma config(Sensor, in3,    TapSensor,      sensorAnalog)
#pragma config(Sensor, in4,    Potent,         sensorPotentiometer)
#pragma config(Sensor, in5,    LinerRight,     sensorLineFollower)
#pragma config(Sensor, in6,    LineMid,        sensorLineFollower)
#pragma config(Sensor, in7,    LineLeft,       sensorLineFollower)
#pragma config(Sensor, dgtl1,  encoRS,         sensorRotation)
#pragma config(Sensor, dgtl2,  encoRS2,        sensorRotation)
#pragma config(Sensor, dgtl7,  encoRS,         sensorRotation)
#pragma config(Sensor, dgtl8,  encoRS2,        sensorRotation)
#pragma config(Sensor, dgtl9,  encoLS,         sensorRotation)
#pragma config(Sensor, dgtl10, encoLS2,        sensorRotation)
#pragma config(Sensor, dgtl11, SonarIN,        sensorSONAR_cm)
#pragma config(Motor,  port1,           rightMotor,    tmotorVex393, openLoop)
#pragma config(Motor,  port2,           Claw,          tmotorVex393, openLoop)
#pragma config(Motor,  port9,           Arm,           tmotorVex269, openLoop)
#pragma config(Motor,  port10,          leftMotor,     tmotorVex393, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//--------------------------------------------------------------------//

#define abs(X) ((X < 0) ? -1 * X : X)
#define BASEDIST 16
const float WHEELBASE = 33.3;
//--------------------------------------------------------------------//

void driveStraight (int dist, int morePower)
{
	int tickGoal = BASEDIST*dist;
	int totalTicks = 0;

	int lessPower = morePower -5;
	int error = 0;
	int kp = 5;

	SensorValue[encoRS] = 0;
	SensorValue[encoLS] = 0;

	while(abs(totalTicks) < tickGoal)
	{
		motor[leftMotor] = morePower;
		motor[rightMotor] = lessPower;

		error = SensorValue[encoLS] - SensorValue[encoRS];
		lessPower += error / kp;

		SensorValue[encoLS] = 0;
		SensorValue[encoRS] = 0;

		wait1Msec(100);
		totalTicks += SensorValue[encoLS];
	}
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
}
//--------------------------------------------------------------------//
void turn(int power, int dir, int deg)
{
	SensorValue[encoLS] = 0;
	SensorValue[encoRS] = 0;

	if (dir == 1)
	{
		while(abs(SensorValue[encoRS])<deg*WHEELBASE)
		{
			motor[leftMotor] = power*-1;
			motor[rightMotor] = power;
		}
	}
	else if (dir == -1)
	{
		while(abs(SensorValue[encoLS])<deg*WHEELBASE){
  		motor[leftMotor] = power;
  		motor[rightMotor] = power*-1;
  	}
  }
}
//-------------------------------------------------------------------//
task main()
{
  turn(40, 1, 50);
  driveStraight(5, 30);
}
//---------------------------------------------------------------------//
